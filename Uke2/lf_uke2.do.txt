TITLE: Løsningshint til uke 2 - Geometriske operasjoner

*Her legges det ut løsningsforslag til programmeringsoppgavene skrevet i Python*

======= Oppgave 1 =======
@@@CODE oppgave1.py
Programmet kan lastes ned "her":"https://github.com/krisbhei/INF2310/blob/master/Uke2/oppgave1.py".
Programmet ser også på hvordan det roterte bildet av Mona ser ut etter forlengs- og baklengs mapping (med og uten interpolasjon).
Dette stod det ikke om i oppgaveteksten, men gjort her for å demonstrere resultatene etter forlengs- og baklengs-mapping.
Bildene som programmet gir, er:

FIGURE: [mona_rotert_forlengs.svg, width=800] Mona med forlengs-mapping av transformkoeffsientene.

FIGURE: [mona_rotert_baklengs.svg, width=800] Mona med baklengs-mapping av transformkoeffsientene.

FIGURE: [mona_rotert_baklengs_bilin.svg, width=800] Mona med baklengs-mapping av transformkoeffsientene og bilineær interpolasjon.

======= Oppgave 3 =======
@@@CODE oppgave3.py
Programmet kan lastes ned "her":"https://github.com/krisbhei/INF2310/blob/master/Uke2/oppgave3.py".

I kommentaren i programmet nevnes det et generelt uttrykk for bilineær interpolasjon. Dette uttrykket er:
!bt
f(x,y) \approx f(x,y_0)\cdot\frac{y_1 - y}{y_1 - y_0} + f(x,y_1)\cdot\frac{y - y_0}{y_1 - y_0} \\
!et

!bt
p = f(x,y_0) \approx f(x_0,y_0)\cdot\frac{x_1 - x}{x_1 - x_0} + f(x_1,y_0)\cdot\frac{x - x_0}{x_1 - x_0} \\
q = f(x,y_1) \approx f(x_0,y_1)\cdot\frac{x_1 - x}{x_1 - x_0} + f(x_1,y_1)\cdot\frac{x - x_0}{x_1 - x_0} \\ \\
!et
,der f står for innbildetsverdier. I utgangspunktet kjenner vi bare bildeverdiene $f(x0,y0),f(x1,y0), f(x0,y1)$ og $f(x1,y1)$.
<linebreak>
Det algoritmen gjør, er å hente ut bildeverdiene fra de nærmeste punktene (det er også mulig å velge punkter lengre unna om man vil, men det holder oftest å velge de nærmeste punktene man kan bruke).
I dette tilfellet, er de nærmeste punktene med 1 piksel avstand mellom x- og y-koordinatene. Dette betyr at
!bt
x_1 - x_0 = 1 \\
y_1 - y_0 = 1
!et
*i denne algoritmen der man henter ut bildeverdier fra de nærmeste punktene*.
Hvis man setter dette inn i uttrykket for bilineær interpolasjon som beskrevet over og setter
!bt
\Delta x = x - x_0 \Leftrightarrow \Delta x + x_0 = x \\
\Delta y = y - y_0 \Leftrightarrow \Delta y + y_0 = y
!et
får man:
!bt
\begin{align*}
p &= f(x_0,y_0)\cdot\frac{x_1 - x}{x_1 - x_0} + f(x_1,y_0)\cdot\frac{x - x_0}{x_1 - x_0} \\
  &= f(x_0,y_0)\cdot(x_1 - x) + f(x_1,y_0)\cdot(x - x_0) \\
  &= f(x_0,y_0)\cdot(x_1 - (\Delta x + x_0)) + f(x_1,y_0)\cdot( (\Delta x + x_0) - x_0) \\
  &= f(x_0,y_0)\cdot(x_1 - x_0 - \Delta x) + f(x_1,y_0)\cdot(\Delta x + x_0 - x_0) \\
  &= f(x_0,y_0)\cdot(1 - \Delta x) + f(x_1,y_0)\cdot \Delta x \\
  &= f(x_0,y_0) - f(x_0,y_0)\cdot \Delta x + f(x_1,y_0)\cdot \Delta x \\
  &= f(x_0,y_0)  + (f(x_1,y_0) - f(x_0,y_0))\cdot \Delta x\\
\end{align*}
!et
På akkurat samme vis kan man vise at
!bt
q = f(x_0,y_1)  + (f(x_1,y_1) - f(x_0,y_1))\cdot \Delta x\\
!et
og deretter
!bt
f(x,y) \approx p + (q - p)\cdot \Delta y
!et
som er algoritmen beskrevet på slide 19 i "lysark om geometriske operasjoner":"http://www.uio.no/studier/emner/matnat/ifi/INF2310/v18/undervisningsmateriale/20180131_geometriskeoperasjoner.pdf".
## doconce format html lf_uke2.do.txt --html_style=bootswatch_yeti --pygments_html_style=friendly --html_admon=bootstrap_panel --html_output=lf --html_code_style=inherit --html_body_style=font-size:16px --cite_doconce

======= Oppgave 4 =======
Her får vi oppgitt at
!bt
\begin{align*}
x &= c_0t + d_0 \\
y &= c_1t + d_1
\end{align*}
!et
For at linjer skal bli bevart etter en affin transformasjon, betyr det at x og y etter transformen kan skrives på samme form som over, dvs:
!bt
\begin{align*}
x' &= c_0't + d_0'\\
y' &= c_1't + d_1'
\end{align*}
!et
for noen konstanter $c_0',d_0',c_1'$ og $d_1'$.
Dette kan man sjekke direkte ved å utføre den affine transformen:
!bt
\begin{align*}
\begin{pmatrix}
x' \\
y' \\
1
\end{pmatrix}
&=
\begin{pmatrix}
a_0 & a_1 & a_2 \\
b_0 & b_1 & b_2 \\
0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
x \\
y \\
1
\end{pmatrix} \\
&=
\begin{pmatrix}
a_0 & a_1 & a_2 \\
b_0 & b_1 & b_2 \\
0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
c_0t + d_0 \\
c_1t + d_1 \\
1
\end{pmatrix} \\
&=
\begin{pmatrix}
a_0(c_0t + d_0)+a_1(c_1t + d_1)+a_2 \\
b_0(c_0t + d_0)+b_1(c_1t + d_1)+ b_2 \\
1
\end{pmatrix} \\
&=
\begin{pmatrix}
(a_0c_0 + a_1c_1)t + a_0d_0 + a_1d_1 + a_2 \\
(b_0c_0 + b_1c_1)t + b_0d_0 + b_1d_1 + b_2 \\
1
\end{pmatrix}
\end{align*}
!et
Hvis en stirrer på uttrykket over, kan en se at det er mulig å sette $c_0' = a_0c_0 + a_1c_1$, $d_0' = a_0d_0 + a_1d_1 + a_2$, $c_1' = b_0c_0 + b_1c_1$ og $d_1' = b_0d_0 + b_1d_1 + b_2$.

<linebreak>

Men da blir:
!bt
\begin{align*}
\begin{pmatrix}
(a_0c_0 + a_1c_1)t + a_0d_0 + a_1d_1 + a_2 \\
(b_0c_0 + b_1c_1)t + b_0d_0 + b_1d_1 + b_2 \\
1
\end{pmatrix}
&=
\begin{pmatrix}
c_0't + d_0'\\
c_1't + d_1'\\
1
\end{pmatrix}
\end{align*}
!et
som betyr at transformen har gitt tilbake rette linjer, men bare med andre stigningstall og konstantledd enn de opprinnelige.
